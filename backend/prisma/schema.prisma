// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
	provider = "prisma-client-js"
}

datasource db {
	provider = "postgresql"
	url      = env("DATABASE_URL")
}

model User {
	id						Int @id @unique
	createdAt				DateTime @default(now())
	updatedAt				DateTime @updatedAt

	email					String @unique
	hash					String

	name					String
	nickname				String @unique
	image					String?

	status					UserStatus @default(OFFLINE) // Offline, In Game, Online

	// lastName String?

	sentFriendRequests		FriendRequest[] @relation("FriendShipRequestor")
	receivedFriendRequests	FriendRequest[] @relation("FriendShipRequestee")
	friends					User[] @relation("Friends")
	friendsOf				User[] @relation("Friends")

	// Game
	Games					Game[] //@relation("WonGames")
	//lostGames				Game[] @relation("LostGames")

    // TODO: Add blocklist

    messages                Message[]
    channels                ChannelUser[]
    ownedChannels           Channel[] @relation("ChannelOwner")
	@@unique([id, nickname])
	@@map("users")
}

model FriendRequest {
	id						String @unique @default(uuid())
	createdAt				DateTime @default(now())
	updatedAt				DateTime @updatedAt

	requestorId				Int
	requestorName			String
	requesteeId				Int
	requesteeName			String
	status					FriendReqStatus @default(PENDING) // Pending, Accepted, Rejected, Blocked

	requestor				User @relation(fields: [requestorId, requestorName], references: [id, nickname], name: "FriendShipRequestor")
	requestee				User @relation(fields: [requesteeId, requesteeName], references: [id, nickname], name: "FriendShipRequestee")

	@@id([requestorId, requesteeId])
	@@index([requestorId, requesteeId], name: "friendship_index")
	@@map("friend_requests")
}

model Message {
    id                      Int @id @default(autoincrement())
    content                 String
    userId                  Int
    user                    User @relation(fields: [userId], references: [id])
    channelId               Int
    channel                 Channel @relation(fields: [channelId], references: [id])
    createdAt               DateTime @default(now())
}

model Channel {
    id                      Int @id @default(autoincrement())
    name                    String? @unique
    password                String?
    messages                Message[]
    users                   ChannelUser[]
    ownerId                 Int?
    owner                   User? @relation("ChannelOwner", fields: [ownerId], references: [id])
	type					ChannelType // Public, Private, Protected, DM
}

model ChannelUser {
    userId                  Int
    user                    User @relation(fields: [userId], references: [id])
    channelId               Int
    channel                 Channel @relation(fields: [channelId], references: [id])
    isMuted                 Boolean @default(false)
    isAdmin                 Boolean @default(false)
    @@id([userId, channelId])
}

enum ChannelType {
	PUBLIC
    PRIVATE
    PROTECTED
    DM
}

// model Game {
// 	id Int @id @unique @default(autoincrement())
// 	createdAt DateTime @default(now())
// 	updatedAt DateTime @updatedAt


// TODO: need to check how spectators will be handled
model Game {
	id						String @id @unique @default(uuid())
	createdAt				DateTime @default(now())
	updatedAt				DateTime @updatedAt

	status					GameStatus @default(NOT_STARTED) // 0: not started, 1: started, 2: ended
	
	players					User[] //@relation("WonGames", fields: [winnerId], references: [id])
	

	gameStats				Json? // winnerId, loserId, winnerScore, loserScore, gameTime, gameDate, gameType
	gameType				GameType // Public, Private, Protected

	@@map("games")
}

// model Chat {
// 	id Int @id @unique @default(autoincrement())
// 	createdAt DateTime @default(now())
// 	updatedAt DateTime @updatedAt

// 	//messages Message[]
// 	users User[]

// 	channelName String @unique
// 	// channel mode may be in front end (public, private, protected by password)
// 	password String? // if protected

// 	channelOwnerId Int
// 	channelOwner User[] @relation("channelOwner", fields: [channelOwnerId], references: [id])
// 	channelAdminId Int
// 	channelAdmin User[] @relation("channelAdmin", fields: [channelAdminId], references: [id])
// 	channelMuteId Int
// 	channelMute User[] @relation("channelMute", fields: [channelMuteId], references: [id])
// 	channelBanId Int
// 	channelBan User[] @relation("channelBan", fields: [channelBanId], references: [id])
// }

// name to be decided
// TODO: work on it
model Customization {
	id						String @unique @default(uuid())
	createdAt DateTime @default(now())
	updatedAt DateTime @updatedAt

	userId Int
	object String

	// avatar
	category String // avatar, background, paddle

	name String

	type String

	description String

	price Int
}


enum FriendReqStatus {
	PENDING
	ACCEPTED
	REJECTED
	BLOCKED
	CANCELLED
}

enum UserStatus {
	OFFLINE
	IN_GAME
	ONLINE
}

enum GameStatus {
	NOT_STARTED
	STARTED
	ENDED
}

// !TODO: needs confirmation
enum GameType {
	PUBLIC
	PRIVATE
	PROTECTED
}